# PageDAO Hub Implementation TODO List

## Project Vision

The PageDAO Hub serves as the central dashboard and API suite for the PageDAO ecosystem, providing comprehensive visibility into token metrics, governance activities, and interactions across multiple blockchains (Ethereum, Optimism, Base, Osmosis). Built as a modular, extensible system with a serverless architecture on Netlify, it implements a sophisticated liquidity-weighted price calculation model and provides both human and machine interfaces for data access.

## Important Implementation Guidelines

- All logic reused from existing .js files must be refactored into new .ts files with proper typing
- Follow consistent naming conventions across all packages
- Design API endpoints with clear, descriptive names that reflect their purpose
- Use these endpoint names consistently throughout the codebase (API implementation, core library, dashboard)
- Implement proper state management for the dashboard to ensure consistent data display
- Document all design decisions with clear rationales
- Prioritize maintainability and extensibility in all architectural decisions
- Follow the three-layer architecture (Data Collection, API, Presentation) as defined in the system architecture
- Implement the comprehensive weighted price calculation algorithm as specified in the implementation plan
- Build the modular package structure with clean separation of concerns

## Critical Issues for Netlify Deployment (PRIORITY)

### 1. Netlify Configuration Consolidation
- [ ] Resolve multiple `netlify.toml` files issue (files exist at root, pagedao-hub/packages/api/netlify.toml, and pagedao-hub/packages/netlify.toml)
- [ ] Create a single authoritative `netlify.toml` at repository root based on the implementation plan
- [ ] Ensure all necessary redirects from all files are included in the consolidated file
- [ ] Verify build command, publish directory, and function paths are correctly specified
- [ ] Document which configuration options came from which original file
- [ ] Validate that the configuration supports the multi-package structure described in the system architecture

### 2. Build Process Standardization
- [ ] Resolve inconsistent build commands across different netlify.toml files
- [ ] Test build.sh script to ensure it works in Netlify environment as described in implementation.txt
- [ ] Document build process including order of package builds (core → api → dashboard)
- [ ] Create a simplified build process for initial deployment testing
- [ ] Verify publish directory configuration (`publish = "public"` vs `publish = "packages/dashboard/dist"`)
- [ ] Implement the incremental build approach outlined in the implementation plan
- [ ] Set up CI/CD pipeline according to the DevOps tasks in the system architecture document

### 3. Dependency Management
- [ ] Audit all package.json files for missing dependencies
- [ ] Add `zod` to packages that import it but don't declare it
- [ ] Ensure consistent versioning across packages for shared dependencies
- [ ] Verify pnpm workspace configuration correctly resolves internal dependencies
- [ ] Test monorepo dependency resolution in Netlify environment
- [ ] Update dependencies to match versions specified in the implementation plan
- [ ] Verify ethers.js v6.13.5 compatibility across all packages
- [ ] Confirm React v19 compatibility in the dashboard package
- [ ] Implement package versioning with Changesets as specified in the architecture document

### 4. Missing Modules and Constants
- [ ] Create missing constants file referenced in code (e.g., TOKEN_DECIMALS in constants.ts)
- [ ] Check all import statements to ensure they resolve correctly
- [ ] Implement any missing utility functions or modules
- [ ] Verify type declarations are complete and consistent
- [ ] Create stubs for any features that are referenced but not yet implemented
- [ ] Implement the standardized interfaces described in the system architecture
- [ ] Create the BlockchainConnector implementations according to the design specifications
- [ ] Build the TVL calculation modules as described in the implementation plan

### 5. Environment Variables
- [ ] Create comprehensive list of all environment variables referenced in the code
- [ ] Document default values and required vs optional status
- [ ] Create .env.example file with all required variables
- [ ] Configure environment variables in Netlify deployment settings
- [ ] Implement validation for critical environment variables
- [ ] Set up secure storage for sensitive configuration as described in the implementation plan
- [ ] Add RPC provider URLs and API keys as specified in the system architecture
- [ ] Implement the environment-specific configuration as described in config.ts

### 6. API/Core Integration
- [ ] Verify @pagedao/core can be properly imported by @pagedao/api
- [ ] Test cross-package function calls
- [ ] Ensure workspace dependencies are correctly defined
- [ ] Create integration tests for core-to-api functionality
- [ ] Document any package-specific build requirements
- [ ] Implement the API endpoints according to the system architecture specification
- [ ] Apply the modular design pattern described in the implementation plan
- [ ] Set up the standard response format for all API endpoints as described in the architecture
- [ ] Implement proper error handling with the pattern defined in the implementation plan

## Deployment Strategy

### 1. Initial Setup
- [ ] Create Netlify site and connect to repository
- [ ] Configure base directory and build settings
- [ ] Set up environment variables for initial deployment
- [ ] Create staging and production environments with branch previews
- [ ] Implement the deployment architecture as described in the system architecture document
- [ ] Set up monitoring and alerting according to the architecture specifications
- [ ] Configure logging and error tracking as detailed in the implementation plan

### 2. Incremental Deployment
- [ ] Start with minimal viable build (just core package)
- [ ] Add API functions one by one, testing each
- [ ] Deploy dashboard without API integration first
- [ ] Connect dashboard to API endpoints gradually
- [ ] Implement monitoring and error tracking
- [ ] Follow the phased approach outlined in the implementation plan
- [ ] Build according to the component dependencies described in the system architecture
- [ ] Implement the backward compatibility strategy for the existing Frame

### 3. Testing Framework
- [ ] Set up end-to-end tests for critical paths
- [ ] Create API endpoint tests
- [ ] Implement unit tests for core functionality
- [ ] Test build process in CI environment
- [ ] Create performance benchmarks for backend functions
- [ ] Implement the comprehensive testing strategy described in both documents
- [ ] Set up mock blockchain responses for consistent testing
- [ ] Create integration tests with test networks
- [ ] Implement the load testing approach for high-traffic scenarios

## Current Progress (as of latest assessment)
- ✅ Basic token configurations defined for multiple chains (Ethereum, Optimism, Base, Osmosis)
- ✅ Support for different pool types (v2, v3) implemented
- ✅ Backup RPC endpoints defined for resilience
- ✅ Cache duration configured (5 minutes)
- ✅ Multi-chain support for Ethereum, Optimism, Base, and Osmosis
- ✅ Initial monorepo structure established with core and API packages
- ✅ Core library package (@pagedao/core) created with TypeScript configuration
- ✅ Token price and TVL API endpoints created with consistent naming patterns
- ✅ Proper TypeScript typing implemented for core components
- ✅ Configuration management with Zod schema validation
- ✅ Environment variable integration in configuration
- ✅ Logging implemented in configuration and providers
- ✅ Helper functions for safe configuration access
- ✅ Advanced provider management with fallback and retry logic
- ✅ Weighted price calculation algorithm implemented
- ✅ Core components extracted and refactored (providers, pricing)
- ✅ Dashboard state management structure defined with Zustand
- ✅ Dashboard API client layer implemented
- ✅ Project setup and configuration files created

## Phase 0: Initial Setup and Migration Planning

### Repository Structure
- ✅ Create monorepo structure with packages directory
- ✅ Create initial package.json for root and each package
- ✅ Set up pnpm-workspace.yaml configuration
- [ ] Set up shared ESLint, Prettier, and TypeScript configs
- [ ] Configure GitHub Actions CI/CD pipeline

### API Design Planning
- ✅ Define comprehensive API endpoint naming strategy
  - ✅ Create consistent naming pattern (e.g., `/api/token/price`, `/api/token/price/:chain`)
  - ✅ Document expected request/response formats for each endpoint
  - ✅ Define error response structure and status codes
- ✅ Create API versioning strategy (e.g., `/api/v1/token/price`)
- [ ] Design webhook API endpoints with security in mind

### Migration Planning
- ✅ Create config.ts with consolidated configuration
  - ✅ Implement Zod schema validation
  - ✅ Add environment variable integration
  - ✅ Implement proper logging
  - ✅ Helper functions for safe access
- ✅ Identify core business logic to extract from Frame
  - ✅ Map out dependencies between existing files
  - ✅ Create migration plan for each component
- ✅ Update netlify.toml for monorepo structure
- [ ] Create deployment strategy document

## Phase 1: Core Library Extraction

### Configuration Management
- ✅ Define RPC provider URLs for multiple chains
- ✅ Implement backup RPC URLs for resilience
- ✅ Define token configurations for multiple chains
- ✅ Create robust configuration management system
  - ✅ Implement .env template with documentation
  - ✅ Add validation for all configuration parameters
  - [ ] Create secure mechanism for updating sensitive configuration
  - [ ] Implement configuration versioning and change tracking
- [ ] Set up secure storage for:
  - [ ] RPC provider URLs and API keys
  - [ ] Webhook secrets and authentication tokens
  - [ ] Base node provider information

### Core Library (@pagedao/core)
- ✅ Create package structure with proper TypeScript configuration
- ✅ Extract and refactor token price fetching from Frame
  - ✅ Migrate getProvider function from web3.js to providers.ts
  - ✅ Refactor fetchPagePrices from tokenServices.js to tokenPrices.ts
  - [ ] Extract pool interaction logic from tokenServices.js to poolService.ts
- ✅ Implement liquidity-weighted price calculation algorithm
  - ✅ Support configurable weighting options
  - [ ] Add validation and confidence scoring
  - [ ] Implement fallback strategies
- ⏩ Develop TVL calculation modules (partially complete)
  - ⏩ Migrate V2 pool TVL calculation from tokenServices.js to tvl/v2PoolCalculator.ts
  - ⏩ Migrate V3 pool TVL calculation from tokenServices.js to tvl/v3PoolCalculator.ts
  - ⏩ Migrate Osmosis pool TVL calculation from tokenServices.js to tvl/osmosisCalculator.ts
- ✅ Create blockchain connector interfaces
  - ✅ Create base BlockchainConnector interface
  - [ ] Ethereum connector implementation (EthereumConnector.ts)
  - [ ] Optimism connector implementation (OptimismConnector.ts)
  - [ ] Base connector implementation (BaseConnector.ts)
  - [ ] Osmosis connector implementation (OsmosisConnector.ts)
- ✅ Implement resilience and error handling
  - ✅ Add retry mechanisms with exponential backoff for RPC calls
  - [ ] Create circuit breakers for external service dependencies
  - ✅ Implement fallback providers for each blockchain
  - [ ] Design graceful degradation paths when services are unavailable
- ✅ Implement caching strategies (basic caching duration defined)
- [ ] Set up comprehensive test suite
  - [ ] Unit tests for calculation functions
  - [ ] Mock blockchain responses
  - [ ] Integration tests with test networks
  - [ ] Load testing for high-volume scenarios

## Phase 2: Data Storage & Persistence

### Data Storage Strategy
- [ ] Design and implement data persistence strategy
  - [ ] Create local storage solution for webhook data
  - [ ] Implement file-based storage for historical price data
  - [ ] Set up backup and recovery procedures for critical data
- [ ] Implement data validation and sanitization
- [ ] Create data migration tools for version upgrades
- [ ] Implement data retention policies

### Caching Layer
- ✅ Implement basic in-memory caching for price data
- [ ] Design multi-level caching strategy
  - [ ] Persistent cache for less volatile data
  - [ ] Implement cache invalidation mechanisms
  - [ ] Add cache warming procedures for cold starts

## Phase 3: API Layer Enhancement

### API Structure
- ✅ Create @pagedao/api package
- ✅ Set up Netlify Functions configuration
  - ✅ Migrate and update netlify.toml
  - [ ] Configure build settings for monorepo
- ✅ Implement consistent error handling and response format
- [ ] Add input validation middleware

### API Endpoints
- ✅ Implement token endpoints
  - ✅ `/api/v1/token/price` - Current token prices across all chains
  - ✅ `/api/v1/token/price/:chain` - Chain-specific price metrics
  - [ ] `/api/v1/token/price/history` - Historical price data
  - [ ] `/api/v1/token/supply` - Supply metrics (circulating, total)
- ✅ Build liquidity endpoints
  - ✅ `/api/v1/liquidity/tvl` - Total TVL across all chains
  - ✅ `/api/v1/liquidity/tvl/:chain` - Chain-specific TVL
  - [ ] `/api/v1/liquidity/pools` - Pool-specific data
- [ ] Create governance endpoints
  - [ ] `/api/v1/governance/proposals` - List proposals
  - [ ] `/api/v1/governance/proposals/:id` - Proposal details
  - [ ] `/api/v1/governance/votes` - Voting statistics
- [ ] Implement Base webhook handler
  - [ ] `/api/v1/webhooks/base` - Base chain event handler
  - [ ] Create secure signature verification
  - [ ] Build event validation and processing
  - [ ] Implement error handling and logging
  - [ ] Add persistent storage for webhook data

### API Documentation
- [ ] Generate OpenAPI/Swagger specifications
- [ ] Create API usage documentation
- [ ] Document rate limiting and usage policies
- [ ] Create architectural decision records (ADRs)

### API Testing
- [ ] Implement comprehensive API testing
  - [ ] Unit tests for all endpoints
  - [ ] Load testing for high-traffic scenarios
  - [ ] Stress testing for webhook handlers
  - [ ] Security testing for authentication mechanisms

## Phase 4: Dashboard Development

### Dashboard Setup
- ✅ Create @pagedao/dashboard package
- ⏩ Configure Vite build system (files present, configuration partial)
- [ ] Set up React Router
- [ ] Implement theme system (light/dark modes)
- [ ] Create responsive layout foundation

### State Management
- ✅ Evaluate and select state management solution (Zustand implemented)
- ✅ Design state structure with clear separation of concerns
  - ✅ Token price state
  - ✅ Liquidity/TVL state
  - ✅ Governance state
  - ✅ UI state (theme, preferences)
- ✅ Implement API data fetching and caching strategy
- ✅ Create selectors for derived data
- ✅ Set up proper error handling in state management

### Dashboard Components
- ⏩ Implement token metrics components (initial files created)
  - [ ] Price display with change indicators
  - [ ] Historical price charts
  - [ ] Chain comparison views
- [ ] Create liquidity visualization components
  - [ ] TVL charts by chain
  - [ ] Pool composition displays
- [ ] Build governance interface components
  - [ ] Proposal listings
  - [ ] Voting interfaces with web3 wallet integration
- [ ] Implement dashboard layout system
  - [ ] Responsive grid layout
  - [ ] Configurable widget system
- ✅ Create user preferences storage

### Dashboard Testing
- [ ] Set up component testing with React Testing Library
- [ ] Implement visual regression testing
- [ ] Add accessibility testing
- [ ] Create end-to-end tests for critical user journeys

## Phase 5: MCP Integration

- [ ] Set up MCP server package structure as specified in the system architecture
- [ ] Implement MCP specification-compliant request/response handling
  - [ ] Ensure full compliance with MCP specification
  - [ ] Validate responses against MCP schema
  - [ ] Implement MCP-specific error handling
- [ ] Create system information and status endpoints
- [ ] Build token price and basic stats endpoints
- [ ] Implement authentication layer with API keys and rate limiting as described
- [ ] Deploy initial MCP server for testing with Claude Desktop
- [ ] Test with multiple AI assistants beyond Claude
- [ ] Develop historical data endpoints with customizable timeframes
- [ ] Create governance data access endpoints
- [ ] Document MCP API for AI assistant developers
- [ ] Implement the natural language interface described in the system architecture

## Phase 6: Monitoring & Observability

- ✅ Implement basic logging throughout core components
- [ ] Develop comprehensive monitoring strategy as detailed in the system architecture
  - [ ] Create custom metrics for key performance indicators
  - [ ] Set up alerting for critical failures and performance degradation
  - [ ] Implement user analytics for dashboard usage patterns
- [ ] Set up monitoring dashboards
  - [ ] API performance metrics
  - [ ] Blockchain connector health
  - [ ] Webhook reliability metrics
  - [ ] User engagement analytics
- [ ] Create operational runbooks
  - [ ] Incident response procedures
  - [ ] Troubleshooting guides for common issues
  - [ ] Performance tuning recommendations
- [ ] Implement the error tracking and reporting system described in the architecture
- [ ] Set up the performance monitoring infrastructure as planned
- [ ] Configure the webhook health monitoring and alerting system

## Phase 7: Integration and Optimization

### Integration
- ✅ Ensure backward compatibility with existing Frame
- [ ] Integrate dashboard with API endpoints
- [ ] Connect web3 wallet providers
- [ ] Implement real-time updates where appropriate

### Performance Optimization
- [ ] Optimize RPC calls to minimize provider costs
- [ ] Implement efficient caching strategies
- [ ] Batch blockchain queries where possible
- [ ] Configure CDN for static assets
- [ ] Optimize bundle sizes for dashboard

### Security Review
- [ ] Conduct security audit of API endpoints
- [ ] Review authentication mechanisms
- [ ] Validate input sanitization
- [ ] Check for sensitive data exposure
- [ ] Implement rate limiting and abuse prevention

## Phase 8: Documentation and Deployment

### Documentation
- [ ] Create comprehensive README files for each package
- [ ] Document all public APIs with JSDoc/TSDoc as specified in the implementation plan
- [ ] Create setup and contribution guides
- [ ] Document deployment procedures
- [ ] Document all environment variables and configuration options
- [ ] Create troubleshooting guides for common issues
- [ ] Document performance expectations and limitations
- [ ] Generate OpenAPI/Swagger specifications as described in the system architecture
- [ ] Create architectural decision records (ADRs) for key design decisions
- [ ] Write Base node operator documentation as detailed in the webhook integration plan
- [ ] Develop the MCP API documentation for AI assistant developers

### Deployment
- [ ] Set up staging environment
- [ ] Configure production environment
- [ ] Implement blue/green deployment strategy
- [ ] Add automated rollback procedures
- [ ] Create disaster recovery plan and test regularly
- [ ] Set up logging and error tracking
- [ ] Create deployment automation scripts

## Special Considerations

### Base Webhook Integration
- [ ] Develop event processor module as detailed in the system architecture
  - [ ] Token transfer processing
  - [ ] Pool update handling
  - [ ] Governance event processing
- [ ] Create webhook configuration interface with API key management
- [ ] Write Base node operator documentation
- [ ] Implement webhook monitoring dashboard
- [ ] Create persistent storage for webhook data
- [ ] Implement webhook replay capability for recovery
- [ ] Build the secure signature verification system described in the architecture
- [ ] Implement the full webhook handler Netlify Function according to specifications
- [ ] Create the event queue/processor as detailed in the architecture

### Backward Compatibility
- ✅ Ensure Frame continues to function during transition
- ✅ Make shared code work with both Frame and Hub
- [ ] Plan migration path for Frame to use new core library
- [ ] Create compatibility layer for legacy API consumers